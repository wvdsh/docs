---
title: "Remote Storage"
description: "Save and sync player files to the cloud"
---

The Remote Storage API lets you save and load player files to cloud storage. Files persist across sessions and devices, enabling features like cloud saves, user preferences, and synced game data.

## Overview

Remote storage provides:
- **Per-user isolation**: Each player has their own storage namespace
- **Cloud sync**: Files persist across devices and sessions
- **Directory support**: Organize files in folders
- **Metadata access**: Get file size, modification time, and more

## Uploading files

<CodeGroup>
```gdscript Godot
func _ready():
    WavedashSDK.remote_file_uploaded.connect(_on_file_uploaded)

func save_to_cloud(local_path: String):
    WavedashSDK.upload_remote_file(local_path)

func _on_file_uploaded(response):
    if response.get("success", false):
        print("File uploaded successfully")
```

```csharp Unity
using Wavedash;

public class CloudSaveExample : MonoBehaviour
{
    public async void SaveToCloud(string localPath)
    {
        var result = await SDK.UploadRemoteFile(localPath);

        if (!string.IsNullOrEmpty(result))
        {
            Debug.Log("File uploaded successfully");
        }
    }
}
```

```javascript JavaScript
const response = await WavedashJS.uploadRemoteFile({
  path: "saves/slot1.json",
  data: new Uint8Array(/* file data */)
});

if (response.success) {
  console.log("File uploaded successfully");
}
```
</CodeGroup>

### Example: Save game data

<CodeGroup>
```gdscript Godot
func save_game(slot: int, game_state: Dictionary):
    var path = "user://saves/slot" + str(slot) + ".json"

    DirAccess.make_dir_recursive_absolute("user://saves")

    var file = FileAccess.open(path, FileAccess.WRITE)
    file.store_string(JSON.stringify(game_state))
    file.close()

    WavedashSDK.upload_remote_file(path)
```

```csharp Unity
public async void SaveGame(int slot, Dictionary<string, object> gameState)
{
    var path = $"{Application.persistentDataPath}/saves/slot{slot}.json";

    Directory.CreateDirectory(Path.GetDirectoryName(path));
    var json = JsonConvert.SerializeObject(gameState);
    File.WriteAllText(path, json);

    await SDK.UploadRemoteFile(path);
}
```

```javascript JavaScript
async function saveGame(slot, gameState) {
  const data = new TextEncoder().encode(JSON.stringify(gameState));

  const response = await WavedashJS.uploadRemoteFile({
    path: `saves/slot${slot}.json`,
    data: data
  });

  return response.success;
}
```
</CodeGroup>

## Downloading files

<CodeGroup>
```gdscript Godot
func _ready():
    WavedashSDK.remote_file_downloaded.connect(_on_file_downloaded)

func load_from_cloud(local_path: String):
    WavedashSDK.download_remote_file(local_path)

func _on_file_downloaded(response):
    if response.get("success", false):
        print("File downloaded successfully")
```

```csharp Unity
public async void LoadFromCloud(string localPath)
{
    var result = await SDK.DownloadRemoteFile(localPath);

    if (!string.IsNullOrEmpty(result))
    {
        Debug.Log("File downloaded successfully");
    }
}
```

```javascript JavaScript
const response = await WavedashJS.downloadRemoteFile({
  path: "saves/slot1.json"
});

if (response.success) {
  const data = response.data;
  const text = new TextDecoder().decode(data);
  const gameState = JSON.parse(text);
}
```
</CodeGroup>

### Example: Load game data

<CodeGroup>
```gdscript Godot
func load_game(slot: int):
    var path = "user://saves/slot" + str(slot) + ".json"
    WavedashSDK.download_remote_file(path)

func _on_file_downloaded(response):
    if response.get("success", false):
        var path = response["data"]["path"]
        if FileAccess.file_exists(path):
            var file = FileAccess.open(path, FileAccess.READ)
            var save_data = JSON.parse_string(file.get_as_text())
            file.close()
            apply_save_data(save_data)
```

```csharp Unity
public async Task<Dictionary<string, object>> LoadGame(int slot)
{
    var path = $"{Application.persistentDataPath}/saves/slot{slot}.json";

    var result = await SDK.DownloadRemoteFile(path);

    if (!string.IsNullOrEmpty(result) && File.Exists(path))
    {
        var json = File.ReadAllText(path);
        return JsonConvert.DeserializeObject<Dictionary<string, object>>(json);
    }

    return null;
}
```

```javascript JavaScript
async function loadGame(slot) {
  const response = await WavedashJS.downloadRemoteFile({
    path: `saves/slot${slot}.json`
  });

  if (response.success && response.data) {
    const text = new TextDecoder().decode(response.data);
    return JSON.parse(text);
  }

  return null;
}
```
</CodeGroup>

## Listing directories

<CodeGroup>
```gdscript Godot
func _ready():
    WavedashSDK.remote_directory_downloaded.connect(_on_directory_downloaded)

func list_saves():
    WavedashSDK.download_remote_directory("user://saves/")

func _on_directory_downloaded(response):
    if response.get("success", false):
        for file in response["data"]:
            print(file["name"], " - ", file["size"], " bytes")
```

```csharp Unity
public async void ListSaves()
{
    var path = $"{Application.persistentDataPath}/saves/";
    var files = await SDK.ListRemoteDirectory(path);

    foreach (var file in files)
    {
        Debug.Log($"{file["name"]} - {file["size"]} bytes");
    }
}
```

```javascript JavaScript
const response = await WavedashJS.listRemoteDirectory({
  path: "saves/"
});

if (response.success) {
  response.data.forEach(file => {
    console.log(`${file.name} - ${file.size} bytes`);
  });
}
```
</CodeGroup>

### File metadata

```typescript
interface RemoteFileMetadata {
  exists: boolean;      // Whether the file exists
  key: string;          // Full storage key
  name: string;         // Filename relative to directory
  lastModified: number; // Unix timestamp
  size: number;         // Size in bytes
  etag: string;         // Version identifier
}
```

## Path conventions

Paths are relative to the user's storage root:

```
saves/               # Directory for save games
saves/slot1.json     # Save file
settings.json        # Root-level file
replays/             # Directory for replays
```

<Note>
Paths should use forward slashes (`/`) as separators, regardless of platform.
</Note>

## Example: Cloud save system

<CodeGroup>
```gdscript Godot
const SAVE_VERSION = 2
const SAVE_PATH = "user://saves/"

func save(slot: int, game_state: Dictionary) -> void:
    var save_data = {
        "version": SAVE_VERSION,
        "timestamp": Time.get_unix_time_from_system(),
        "state": game_state
    }

    var path = SAVE_PATH + "slot" + str(slot) + ".json"
    DirAccess.make_dir_recursive_absolute(SAVE_PATH)

    var file = FileAccess.open(path, FileAccess.WRITE)
    file.store_string(JSON.stringify(save_data))
    file.close()

    WavedashSDK.upload_remote_file(path)
```

```csharp Unity
private const int SaveVersion = 2;

public async Task<bool> Save(int slot, Dictionary<string, object> gameState)
{
    var saveData = new Dictionary<string, object>
    {
        { "version", SaveVersion },
        { "timestamp", DateTimeOffset.UtcNow.ToUnixTimeSeconds() },
        { "state", gameState }
    };

    var path = $"{Application.persistentDataPath}/saves/slot{slot}.json";
    Directory.CreateDirectory(Path.GetDirectoryName(path));

    var json = JsonConvert.SerializeObject(saveData);
    File.WriteAllText(path, json);

    var result = await SDK.UploadRemoteFile(path);
    return !string.IsNullOrEmpty(result);
}
```

```javascript JavaScript
class CloudSaveSystem {
  constructor() {
    this.saveVersion = 2;
  }

  async save(slot, gameState) {
    const saveData = {
      version: this.saveVersion,
      timestamp: Date.now(),
      state: gameState
    };

    const data = new TextEncoder().encode(JSON.stringify(saveData));

    const response = await WavedashJS.uploadRemoteFile({
      path: `saves/slot${slot}.json`,
      data: data
    });

    return response.success;
  }

  async load(slot) {
    const response = await WavedashJS.downloadRemoteFile({
      path: `saves/slot${slot}.json`
    });

    if (!response.success || !response.data) {
      return null;
    }

    const text = new TextDecoder().decode(response.data);
    return JSON.parse(text).state;
  }
}
```
</CodeGroup>
