---
title: "P2P Networking"
description: "Connect players directly with peer-to-peer WebRTC networking"
---

The P2P API enables direct communication between players using WebRTC. This provides low-latency data transfer for real-time multiplayer games without routing through a server.

## How it works

When players join a lobby, the SDK automatically:

1. Establishes WebRTC connections between all lobby members
2. Sets up reliable and unreliable data channels
3. Handles NAT traversal using TURN servers when needed
4. Notifies your game when connections are ready

## Connection lifecycle

<Steps>
  <Step title="Join a lobby">
    P2P connections are established automatically when you join a lobby.
  </Step>
  <Step title="Wait for connections">
    Listen for `P2P_CONNECTION_ESTABLISHED` signals as each peer connects.
  </Step>
  <Step title="Send and receive data">
    Use `sendP2PMessage` or `broadcastP2PMessage` to communicate.
  </Step>
  <Step title="Handle disconnections">
    Listen for `P2P_PEER_DISCONNECTED` to handle players leaving.
  </Step>
</Steps>

## Sending messages

### Broadcast to all peers

Send a message to all connected peers:

```javascript
const response = await WavedashJS.broadcastP2PMessage({
  channel: 0,
  data: new Uint8Array([1, 2, 3, 4]),
  reliable: true  // Use reliable channel (default)
});
```

### Send to a specific peer

Send a message to one peer:

```javascript
const response = await WavedashJS.sendP2PMessage({
  userId: targetUserId,
  channel: 0,
  data: new Uint8Array([1, 2, 3, 4]),
  reliable: false  // Use unreliable channel for speed
});
```

### Parameters

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `userId` | string | For unicast | Target peer's user ID |
| `channel` | number | Yes | Channel number (0-7) |
| `data` | Uint8Array | Yes | Binary data to send |
| `reliable` | boolean | No | Use reliable channel (default: true) |

## Receiving messages

Messages are delivered via the `P2P_MESSAGE` signal or can be read from message queues:

```javascript
// Read from a specific channel
const message = WavedashJS.readP2PMessageFromChannel(0);

if (message) {
  console.log(`From: ${message.fromUserId}`);
  console.log(`Channel: ${message.channel}`);
  console.log(`Data: ${message.payload}`);
}
```

### Message structure

```typescript
interface P2PMessage {
  fromUserId: string;   // Sender's user ID
  channel: number;      // Channel the message was sent on
  payload: Uint8Array;  // Binary data
}
```

## Channels

The SDK supports up to 8 channels (0-7) for organizing different types of game data:

| Channel | Suggested use |
|---------|---------------|
| 0 | Game state updates |
| 1 | Player input |
| 2 | Chat messages |
| 3 | Voice data |
| 4-7 | Custom use |

<Tip>
Use separate channels for different data types to help organize your networking code and potentially prioritize certain messages.
</Tip>

## Reliable vs unreliable

The SDK provides two types of data channels:

| Type | Description | Best for |
|------|-------------|----------|
| **Reliable** | Guaranteed delivery, ordered | Important state, chat, game events |
| **Unreliable** | Best-effort, faster | Position updates, input, frequent data |

```javascript
// Reliable - guaranteed delivery (like TCP)
WavedashJS.broadcastP2PMessage({
  channel: 0,
  data: gameStateData,
  reliable: true
});

// Unreliable - faster but may drop (like UDP)
WavedashJS.broadcastP2PMessage({
  channel: 1,
  data: positionData,
  reliable: false
});
```

## Connection state

Check the P2P connection state:

```javascript
const connection = WavedashJS.getP2PConnection();

if (connection) {
  console.log(`Lobby: ${connection.lobbyId}`);
  console.log(`State: ${connection.state}`);
  console.log(`Peers: ${Object.keys(connection.peers).length}`);
}
```

### Connection states

| State | Description |
|-------|-------------|
| `connecting` | Establishing connections |
| `connected` | All peers connected |
| `disconnected` | Connection closed normally |
| `failed` | Connection failed |

## Signals

| Signal | Description | Data |
|--------|-------------|------|
| `P2P_CONNECTION_ESTABLISHED` | Peer connected successfully | `{ userId, username }` |
| `P2P_CONNECTION_FAILED` | Connection to peer failed | `{ userId, error }` |
| `P2P_PEER_DISCONNECTED` | Peer disconnected | `{ userId }` |
| `P2P_MESSAGE` | Message received | `{ fromUserId, channel, payload }` |

## TURN fallback

When direct peer-to-peer connections fail (due to strict NAT or firewalls), the SDK automatically falls back to TURN servers for relay. This ensures connectivity at the cost of slightly higher latency.

<Note>
TURN credentials are managed automatically by the SDK. No configuration is required.
</Note>

## Peer information

Access information about connected peers:

```javascript
const connection = WavedashJS.getP2PConnection();

if (connection) {
  for (const [userId, peer] of Object.entries(connection.peers)) {
    console.log(`Peer: ${peer.username} (${peer.userId})`);
  }
}
```

### Peer structure

```typescript
interface P2PPeer {
  userId: string;    // Peer's user ID
  username: string;  // Peer's display name
}
```

## Best practices

<AccordionGroup>
  <Accordion title="Use unreliable for frequent updates">
    Position updates, input, and other frequently-sent data should use the unreliable channel to avoid head-of-line blocking.
  </Accordion>
  <Accordion title="Use reliable for important events">
    Game state changes, chat messages, and critical events should use the reliable channel.
  </Accordion>
  <Accordion title="Handle disconnections gracefully">
    Always listen for `P2P_PEER_DISCONNECTED` and update your game state accordingly.
  </Accordion>
  <Accordion title="Keep messages small">
    P2P messages should be as small as possible. Consider compression for larger data.
  </Accordion>
  <Accordion title="Use channels to organize data">
    Separate different types of data into different channels for cleaner code and easier debugging.
  </Accordion>
</AccordionGroup>
