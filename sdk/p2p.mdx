---
title: "P2P Networking"
description: "Connect players directly with peer-to-peer WebRTC networking"
---

The P2P API enables direct communication between players using WebRTC. This provides low-latency data transfer for real-time multiplayer games without routing through a server.

## How it works

When players join a lobby, the SDK automatically:

1. Establishes WebRTC connections between all lobby members
2. Sets up reliable and unreliable data channels
3. Handles NAT traversal using TURN servers when needed
4. Notifies your game when connections are ready

## Sending messages

### Broadcast to all peers

<CodeGroup>
```gdscript Godot
func broadcast_to_all(data: PackedByteArray, reliable: bool = true):
    # Empty string for target = broadcast to all peers
    WavedashSDK.send_p2p_message("", data, 0, reliable)

# Example: Send game state
func send_game_state(state: Dictionary):
    var json = JSON.stringify(state)
    var data = json.to_utf8_buffer()
    broadcast_to_all(data, true)
```

```csharp Unity
public void BroadcastToAll(byte[] data, int channel = 0, bool reliable = true)
{
    SDK.BroadcastP2PMessage(data, channel, reliable);
}

// Example: Send game state
public void SendGameState(string jsonState)
{
    var data = System.Text.Encoding.UTF8.GetBytes(jsonState);
    BroadcastToAll(data, channel: 0, reliable: true);
}
```

```javascript JavaScript
WavedashJS.broadcastP2PMessage(
  0,                           // channel
  true,                        // reliable
  new Uint8Array([1, 2, 3, 4]) // payload
);
```
</CodeGroup>

### Send to a specific peer

<CodeGroup>
```gdscript Godot
func send_to_peer(user_id: String, data: PackedByteArray, reliable: bool = true):
    WavedashSDK.send_p2p_message(user_id, data, 0, reliable)
```

```csharp Unity
public void SendToPeer(string userId, byte[] data, int channel = 0, bool reliable = true)
{
    SDK.SendP2PMessage(userId, data, channel, reliable);
}
```

```javascript JavaScript
WavedashJS.sendP2PMessage(
  targetUserId,                // userId (or undefined for broadcast)
  0,                           // channel
  false,                       // reliable
  new Uint8Array([1, 2, 3, 4]) // payload
);
```
</CodeGroup>

### Parameters

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `userId` | string | For unicast | Target peer's user ID |
| `channel` | number | Yes | Channel number (0-7) |
| `data` | Uint8Array | Yes | Binary data to send |
| `reliable` | boolean | No | Use reliable channel (default: true) |

## Receiving messages

<CodeGroup>
```gdscript Godot
func _process(_delta):
    var messages = WavedashSDK.receive_p2p_messages_on_channel(0, 32)
    for msg in messages:
        handle_message(msg)

func handle_message(msg: Dictionary):
    var from_user = msg["identity"]
    var payload: PackedByteArray = msg["payload"]
    var data_string = payload.get_string_from_utf8()
    print("From ", from_user, ": ", data_string)
```

```csharp Unity
void Update()
{
    var messages = SDK.ReceiveP2PMessagesOnChannel(0, maxMessages: 32);
    foreach (var msg in messages)
    {
        HandleMessage(msg);
    }
}

void HandleMessage(Dictionary<string, object> msg)
{
    var fromUser = msg["identity"].ToString();
    var payload = (byte[])msg["payload"];
    var dataString = System.Text.Encoding.UTF8.GetString(payload);
    Debug.Log($"From {fromUser}: {dataString}");
}
```

```javascript JavaScript
const message = WavedashJS.readP2PMessageFromChannel(0);

if (message) {
  console.log(`From: ${message.fromUserId}`);
  console.log(`Data: ${message.payload}`);
}
```
</CodeGroup>

## Channels

The SDK supports up to 8 channels (0-7):

| Channel | Suggested use |
|---------|---------------|
| 0 | Game state updates |
| 1 | Player input |
| 2 | Chat messages |
| 3 | Voice data |
| 4-7 | Custom use |

## Reliable vs unreliable

| Type | Description | Best for |
|------|-------------|----------|
| **Reliable** | Guaranteed delivery, ordered | Important state, chat, game events |
| **Unreliable** | Best-effort, faster | Position updates, input, frequent data |

<CodeGroup>
```gdscript Godot
# Reliable - guaranteed delivery (like TCP)
func send_important_event(data: PackedByteArray):
    WavedashSDK.send_p2p_message("", data, 0, true)

# Unreliable - faster but may drop (like UDP)
func send_position_update(data: PackedByteArray):
    WavedashSDK.send_p2p_message("", data, 1, false)
```

```csharp Unity
// Reliable - guaranteed delivery (like TCP)
public void SendImportantEvent(byte[] data)
{
    SDK.BroadcastP2PMessage(data, channel: 0, reliable: true);
}

// Unreliable - faster but may drop (like UDP)
public void SendPositionUpdate(byte[] data)
{
    SDK.BroadcastP2PMessage(data, channel: 1, reliable: false);
}
```

```javascript JavaScript
// Reliable - guaranteed delivery (like TCP)
WavedashJS.broadcastP2PMessage(0, true, gameStateData);

// Unreliable - faster but may drop (like UDP)
WavedashJS.broadcastP2PMessage(1, false, positionData);
```
</CodeGroup>

## Connection state

Check if peers are ready for messaging:

<CodeGroup>
```gdscript Godot
# Check if we can broadcast to at least one peer
func can_broadcast() -> bool:
    # P2P connections are managed automatically when in a lobby
    # Use signals to track connection state
    return true  # Check via p2p_connection_established signal
```

```csharp Unity
// P2P connections are managed automatically when in a lobby
// Listen to OnP2PConnectionEstablished to know when peers are ready
```

```javascript JavaScript
// Check if a specific peer is ready
const isReady = WavedashJS.isPeerReady(userId);

// Check if broadcast is ready (at least one peer connected)
const canBroadcast = WavedashJS.isBroadcastReady();
```
</CodeGroup>

## Signals

<CodeGroup>
```gdscript Godot
func _ready():
    WavedashSDK.p2p_connection_established.connect(_on_p2p_connected)
    WavedashSDK.p2p_connection_failed.connect(_on_p2p_failed)
    WavedashSDK.p2p_peer_disconnected.connect(_on_p2p_disconnected)

func _on_p2p_connected(payload):
    print("P2P connected to: ", payload["userId"])

func _on_p2p_failed(payload):
    print("P2P connection failed")

func _on_p2p_disconnected(payload):
    print("P2P peer disconnected: ", payload["userId"])
```

```csharp Unity
void Awake()
{
    SDK.OnP2PConnectionEstablished += data => Debug.Log($"P2P connected to: {data["userId"]}");
    SDK.OnP2PConnectionFailed += data => Debug.Log("P2P connection failed");
    SDK.OnP2PPeerDisconnected += data => Debug.Log($"P2P peer disconnected: {data["userId"]}");
}
```

```javascript JavaScript
// Signals emitted for P2P events:
// P2P_CONNECTION_ESTABLISHED - { userId, username }
// P2P_CONNECTION_FAILED - { userId, error }
// P2P_PEER_DISCONNECTED - { userId }
```
</CodeGroup>

| Signal | Description | Data |
|--------|-------------|------|
| `P2P_CONNECTION_ESTABLISHED` | Peer connected | `{ userId, username }` |
| `P2P_CONNECTION_FAILED` | Connection failed | `{ userId, error }` |
| `P2P_PEER_DISCONNECTED` | Peer disconnected | `{ userId }` |

## TURN fallback

When direct connections fail, the SDK automatically falls back to TURN servers for relay.

<Note>
TURN credentials are managed automatically. No configuration required.
</Note>
