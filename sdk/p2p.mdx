---
title: "P2P Networking"
description: "Connect players directly with peer-to-peer WebRTC networking"
---

The P2P API enables direct communication between players using WebRTC. This provides low-latency data transfer for real-time multiplayer games without routing through a server.

## How it works

When players join a lobby, the SDK automatically:

1. Establishes WebRTC connections between all lobby members
2. Sets up reliable and unreliable data channels
3. Handles NAT traversal using TURN servers when needed
4. Notifies your game when connections are ready

## Sending messages

### Broadcast to all peers

<CodeGroup>
```gdscript Godot
func broadcast_to_all(data: PackedByteArray, reliable: bool = true):
    # Empty string for target = broadcast to all peers
    WavedashSDK.send_p2p_message("", data, 0, reliable)

# Example: Send game state
func send_game_state(state: Dictionary):
    var json = JSON.stringify(state)
    var data = json.to_utf8_buffer()
    broadcast_to_all(data, true)
```

```csharp Unity
public void BroadcastToAll(byte[] data, int channel = 0, bool reliable = true)
{
    SDK.BroadcastP2PMessage(data, channel, reliable);
}

// Example: Send game state
public void SendGameState(string jsonState)
{
    var data = System.Text.Encoding.UTF8.GetBytes(jsonState);
    BroadcastToAll(data, channel: 0, reliable: true);
}
```

```javascript JavaScript
const response = await WavedashJS.broadcastP2PMessage({
  channel: 0,
  data: new Uint8Array([1, 2, 3, 4]),
  reliable: true
});
```
</CodeGroup>

### Send to a specific peer

<CodeGroup>
```gdscript Godot
func send_to_peer(user_id: String, data: PackedByteArray, reliable: bool = true):
    WavedashSDK.send_p2p_message(user_id, data, 0, reliable)
```

```csharp Unity
public void SendToPeer(string userId, byte[] data, int channel = 0, bool reliable = true)
{
    SDK.SendP2PMessage(userId, data, channel, reliable);
}
```

```javascript JavaScript
const response = await WavedashJS.sendP2PMessage({
  userId: targetUserId,
  channel: 0,
  data: new Uint8Array([1, 2, 3, 4]),
  reliable: false
});
```
</CodeGroup>

### Parameters

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `userId` | string | For unicast | Target peer's user ID |
| `channel` | number | Yes | Channel number (0-7) |
| `data` | Uint8Array | Yes | Binary data to send |
| `reliable` | boolean | No | Use reliable channel (default: true) |

## Receiving messages

<CodeGroup>
```gdscript Godot
func _process(_delta):
    var messages = WavedashSDK.receive_p2p_messages_on_channel(0, 32)
    for msg in messages:
        handle_message(msg)

func handle_message(msg: Dictionary):
    var from_user = msg["identity"]
    var payload: PackedByteArray = msg["payload"]
    var data_string = payload.get_string_from_utf8()
    print("From ", from_user, ": ", data_string)
```

```csharp Unity
void Update()
{
    var messages = SDK.ReceiveP2PMessagesOnChannel(0, maxMessages: 32);
    foreach (var msg in messages)
    {
        HandleMessage(msg);
    }
}

void HandleMessage(Dictionary<string, object> msg)
{
    var fromUser = msg["identity"].ToString();
    var payload = (byte[])msg["payload"];
    var dataString = System.Text.Encoding.UTF8.GetString(payload);
    Debug.Log($"From {fromUser}: {dataString}");
}
```

```javascript JavaScript
const message = WavedashJS.readP2PMessageFromChannel(0);

if (message) {
  console.log(`From: ${message.fromUserId}`);
  console.log(`Data: ${message.payload}`);
}
```
</CodeGroup>

## Channels

The SDK supports up to 8 channels (0-7):

| Channel | Suggested use |
|---------|---------------|
| 0 | Game state updates |
| 1 | Player input |
| 2 | Chat messages |
| 3 | Voice data |
| 4-7 | Custom use |

## Reliable vs unreliable

| Type | Description | Best for |
|------|-------------|----------|
| **Reliable** | Guaranteed delivery, ordered | Important state, chat, game events |
| **Unreliable** | Best-effort, faster | Position updates, input, frequent data |

<CodeGroup>
```gdscript Godot
# Reliable - guaranteed delivery (like TCP)
func send_important_event(data: PackedByteArray):
    WavedashSDK.send_p2p_message("", data, 0, true)

# Unreliable - faster but may drop (like UDP)
func send_position_update(data: PackedByteArray):
    WavedashSDK.send_p2p_message("", data, 1, false)
```

```csharp Unity
// Reliable - guaranteed delivery (like TCP)
public void SendImportantEvent(byte[] data)
{
    SDK.BroadcastP2PMessage(data, channel: 0, reliable: true);
}

// Unreliable - faster but may drop (like UDP)
public void SendPositionUpdate(byte[] data)
{
    SDK.BroadcastP2PMessage(data, channel: 1, reliable: false);
}
```

```javascript JavaScript
// Reliable
WavedashJS.broadcastP2PMessage({ channel: 0, data: gameStateData, reliable: true });

// Unreliable
WavedashJS.broadcastP2PMessage({ channel: 1, data: positionData, reliable: false });
```
</CodeGroup>

## Connection state

<CodeGroup>
```gdscript Godot
func check_connection_state():
    var connection = WavedashSDK.get_p2p_connection()
    if connection:
        print("Lobby: ", connection["lobbyId"])
        print("State: ", connection["state"])
        print("Peers: ", connection["peers"].size())
```

```csharp Unity
public void CheckConnectionState()
{
    var connection = SDK.GetP2PConnection();
    if (connection != null)
    {
        Debug.Log($"Lobby: {connection["lobbyId"]}");
        Debug.Log($"State: {connection["state"]}");
    }
}
```

```javascript JavaScript
const connection = WavedashJS.getP2PConnection();

if (connection) {
  console.log(`Lobby: ${connection.lobbyId}`);
  console.log(`State: ${connection.state}`);
  console.log(`Peers: ${Object.keys(connection.peers).length}`);
}
```
</CodeGroup>

### Connection states

| State | Description |
|-------|-------------|
| `connecting` | Establishing connections |
| `connected` | All peers connected |
| `disconnected` | Connection closed normally |
| `failed` | Connection failed |

## Signals

<CodeGroup>
```gdscript Godot
func _ready():
    WavedashSDK.p2p_connection_established.connect(_on_p2p_connected)
    WavedashSDK.p2p_connection_failed.connect(_on_p2p_failed)
    WavedashSDK.p2p_peer_disconnected.connect(_on_p2p_disconnected)

func _on_p2p_connected(payload):
    print("P2P connected to: ", payload["userId"])

func _on_p2p_failed(payload):
    print("P2P connection failed")

func _on_p2p_disconnected(payload):
    print("P2P peer disconnected: ", payload["userId"])
```

```csharp Unity
void Awake()
{
    SDK.OnP2PConnectionEstablished += data => Debug.Log($"P2P connected to: {data["userId"]}");
    SDK.OnP2PConnectionFailed += data => Debug.Log("P2P connection failed");
    SDK.OnP2PPeerDisconnected += data => Debug.Log($"P2P peer disconnected: {data["userId"]}");
}
```

```javascript JavaScript
// Signals emitted for P2P events:
// P2P_CONNECTION_ESTABLISHED - { userId, username }
// P2P_CONNECTION_FAILED - { userId, error }
// P2P_PEER_DISCONNECTED - { userId }
```
</CodeGroup>

| Signal | Description | Data |
|--------|-------------|------|
| `P2P_CONNECTION_ESTABLISHED` | Peer connected | `{ userId, username }` |
| `P2P_CONNECTION_FAILED` | Connection failed | `{ userId, error }` |
| `P2P_PEER_DISCONNECTED` | Peer disconnected | `{ userId }` |

## TURN fallback

When direct connections fail, the SDK automatically falls back to TURN servers for relay.

<Note>
TURN credentials are managed automatically. No configuration required.
</Note>
